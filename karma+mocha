参考文献：
http://annn.me/frontend-ci-cd/
http://karma-runner.github.io/0.12/plus/jenkins.html
http://powertech.iteye.com/blog/2051387
http://www.shenyanchao.cn/blog/2013/04/01/run-karma-in-jenkins-ci/
http://www.shenyanchao.cn/blog/2013/03/27/use-karma-to-run-mocha-test/
http://www.51testing.com/html/70/n-3720170.html
https://github.com/nupthale/jasmine_karma_travis

1.单测框架（即 mocha）Mocha的作用是运行测试脚本
 测试脚本里面应该包括一个或多个describe块，每个describe块应该包括一个或多个it块。
describe块称为“测试套件”（test suite），表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称（“加法函数的测试”），第二个参数是一个实际执行的函数。
it块称为“测试用例”（test case），表示一个单独的测试，是测试的最小单位。它也是一个函数，第一个参数是测试用例的名称（“1 加 1 应该等于 2”），第二个参数是一个实际执行的函数。
断言库有很多种，mocha 并不限制使用哪一种。上面代码引入的断言库是 chai，并且指定使用它的assert断言风格。因为这更接近其它语言的风格。
所谓"断言"，就是判断源码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误
expect断言风格 var expect = require('chai').expect;
             expect(4 + 5).to.be.equal(9); 其中equal是expect的方法
             如果expect断言不成立，就会抛出一个错误。事实上，只要不抛出错误，测试用例就算通过。

可以集成到webstorm里单测可用在run-->edit config-->mocha-(写上文件目录*.test.js 或者*.spec.js)

2.Karma 不是一个测试框架，也不是一个断言库，仅仅启动一个 http server，并通过你熟知的测试框架生成运行测试的HTML。
karma init my.conf.js命令生成配置文件
    frameworks：我们这里需要 mocha 和 chai。框架必须预先通过 npm install karma-xxx --save-dev 命令安装好，支持的框架详见：https://www.npmjs.com/browse/keyword/karma-adapter
    files：可以配置通配符把源代码和测试代码加载进来。
    browsers：需要启动的浏览器
    autoWatch：观察文件是否变动，如有变动则重新运行单测
    preprocessors 预处理器配置,这里配置哪些文件需要统计测试覆盖率, 例如, 如果你的所有代码文件都在 js文件夹中, 你就需要如下配置. 注意不要包含你所依赖的库，测试文件等等
    reports 报告配置,在配置文件中包含下面的信息来激活覆盖率报告器.
    // 浏览器
    browsers: ['PhantomJS'],
    // 测试框架
    frameworks: ['mocha', 'sinon-chai', 'phantomjs-shim'],
    // 测试报告
    reporters: ['spec', 'coverage'],
    // 测试入口文件
    files: ['./index.js'],
    // 预处理器 karma-webpack
    preprocessors: {
      './index.js': ['webpack', 'sourcemap']
    },
    // Webpack配置
    webpack: webpackConfig,
    // Webpack中间件
    webpackMiddleware: {
      noInfo: true
    },
    // 测试覆盖率报告
    // https://github.com/karma-runner/karma-coverage/blob/master/docs/configuration.md
    coverageReporter: {
      dir: './coverage',
      reporters: [
        { type: 'lcov', subdir: '.' },
        { type: 'text-summary' }
      ]
    }
    
    /***
         * 基础路径，用在files，exclude属性上
         */
        basePath: "",

        /**
         * 测试框架
         * 可用的框架：https://npmjs.org/browse/keyword/karma-adapter
         */
        frameworks: ["jasmine"],

        /**
         * 需要加载到浏览器的文件列表
         */
        files: [
            "karmaTest/*.js"
        ],

        /**
         * 排除的文件列表
         */
        exclude: [
        ],

        /**
         * 在浏览器使用之前处理匹配的文件
         * 可用的预处理: https://npmjs.org/browse/keyword/karma-preprocessor
         */
        preprocessors: {
            "karmaTest/test.js" : "coverage"
        },

        /**
         * 使用测试结果报告者
         * 可能的值: "dots", "progress"
         * 可用的报告者：https://npmjs.org/browse/keyword/karma-reporter
         */
        reporters: ["progress", "coverage"],

        /**
         * 使用reporters为"coverage"时报告输出的类型和那目录
         */
        coverageReporter: {
            type: "html",
            dir: "karmaTest/coverage"
        },

        /**
         * 服务端口号
         */
        port: 9876,

        /**
         * 启用或禁用输出报告或者日志中的颜色
         */
        colors: true,

        /**
         * 日志等级
         * 可能的值：
         * config.LOG_DISABLE //不输出信息
         * config.LOG_ERROR    //只输出错误信息
         * config.LOG_WARN //只输出警告信息
         * config.LOG_INFO //输出全部信息
         * config.LOG_DEBUG //输出调试信息
         */
        logLevel: config.LOG_INFO,

        /**
         * 启用或禁用自动检测文件变化进行测试
         */
        autoWatch: true,


        /**
         * 测试启动的浏览器
         * 可用的浏览器：https://npmjs.org/browse/keyword/karma-launcher
         */
        browsers: ["Chrome"],


        /**
         * 开启或禁用持续集成模式
         * 设置为true, Karma将打开浏览器，执行测试并最后退出
         */
        singleRun: true,

        /**
         * 并发级别（启动的浏览器数）
         */
        concurrency: Infinity
        
优点：1. cli（command-line interface，命令行界面） 运行，webstorm下配合完美 
      2. 良好支持 mocha、jasmine 等测试框架 
      3. 支持多浏览器的测试 
      4. 生态好，插件多 
      5. 集成监控解放双手，文件变化时自动启测，类似gulp的watch功能
    
3.命令行指定测试脚本时，可以使用通配符，同时指定多个文件。
shell通配符表示： $ mocha test/{,**/}*.{js,jsx}
node通配符表示： $ mocha 'test/**/*.@(js|jsx)'

Chai是一个单元测试的验证框架，它有3种不同形式的校验：expect、should和assert。expect和should的方式让写出来的测试代码更像自然语言，让业务人员也可以看懂，
而assert方式是传统单元测试断言的方式，如果以前习惯写Java的单元测试会对这种方式比较熟悉。

4。react单元测试常常与webpack工具结合

5.测试之chai.js断言库
chai.js 是一套TDD(测试驱动开发---注重输出结果)/BDD(行为驱动开发--注重测试逻辑)的断言库
语言链修饰符：to
be
been
is
that
which
and
has
have
with
at
of
same

具体api说明：
any/all
.a(type) / .an(type)： 用来断言变量类型
.include(value) / contains(value)：Object | String | Number，包含某个内容
not 跟在链式调用后面的否定断言
deep 用来深度比较2个对象,一般用在equal和property前面
.ok 断言目标是否为真(只判断值是否为真，类似==，隐式转换)
.true/.false 断言目标是否为布尔值true,false（这里与ok的区别是不进行类型转换，只能为true/false才能通过断言）
.null 断言目标为null
.undefined 断言目标为undefined
NaN 断言目标为NaN
exist 断言目标存在，既不为null，也不为undefined
empty 断言目标的长度为0。对于数组和字符串，它检查length属性，对于对象，它检查可枚举属性的数量
arguments 断言目标是一个参数对象arguments
equal(value) 断言目标严格等于(===)value。另外，如果设置了deep标记，则断言目标深度等于value
eql(value) 断言目标深度等于value，相当于deep.equal(value)的简写
above(value) 断言目标大于（超过）value,也可接在length后来断言一个最小的长度。相比直接提供长度的好处是提供了更详细的错误消息
least(value) 断言目标不小于，也可接在length后来断言一个最小的长度。相比直接提供长度的好处是提供了更详细的错误消息
below(value) 断言目标小于，也可接在length后来断言一个最小的长度。相比直接提供长度的好处是提供了更详细的错误消息
most(value) 断言目标不大于，也可接在length后来断言一个最小的长度。相比直接提供长度的好处是提供了更详细的错误消息
length 设置.have.length标记作为比较length属性值的前缀
lengthof() 断言目标的length属性为期望的值
match(RegExp) 断言目标匹配到一个正则表达式
string(string) 断言目标字符串包含另一个字符串

  “测试覆盖是一种学习手段”。学习什么呢？学习为什么有些代码没有被覆盖到，以及为什么有些代码变了测试却没有失败。理解“为什么”背后的原因，
  程序员就可以做相应的改善和提高，相比凭空想象单元测试的有效性和代码的好坏，这会更加有效。

6.bug
（1）WARN [plugin]: Error during loading "karma-phantomjs-launcher" plugin:
  Path must be a string. Received null
  --------插件安装在--save-dev中，不要重复 （无界面的浏览器） 
  
 (2)karma浏览器显示与否 singleRun: false  才能显示，不然浏览器会自动关闭
 
（3）autoWatch：true 与 singleRun: true 冲突  
   因为我们使用的是jasmine测试框架， 所以还要声明karma-jasmine。在远端Travis服务上， 我们不需要autoWatch， 否则任务无法结束，
   设置autoWatch为false， 浏览器测试完毕后需要关闭， 所以设置singleRun为true。
 
 (4)coverage遍历的文件夹不清楚怎么写？
 
（5)若executed 执行全部成功将不会报错npm的错，且process code 0,否则process code 1
 

 

  
  
  
 
  
  const webpackConfig = require('./webpack.config.js');

module.exports = function (config)
{
    config.set({
                   basePath  : '../',
                   frameworks: ['mocha'],
        
                   reporters: ['dots', 'junit'],
        
                   junitReporter: {
                       outputFile: 'test-results.xml'
                   },
    
                   port               : 9876,
                   colors             : true,
                   logLevel           : config.LOG_DEBUG,
                   autoWatch          : true,
                   browsers           : ['Chrome'],
                   singleRun          : true,
                   autoWatchBatchDelay: 3000,
        
                   files: [
                       './test/**/*Spec.js'
                   ],
        
                   loader: 'babel-loader',
        
                   preprocessors: {
                       './test/**/*Spec.js': ['webpack']
                   },
        
                   webpack: webpackConfig(),
        
                   webpackMiddleware: {
                       noInfo: true
                   },
        
                   captureTimeout: 60000,
        
                   plugins: [
                       'karma-mocha',
                       'karma-chrome-launcher',
                       'karma-junit-reporter',
                       'karma-webpack'
                   ]
               });
};







