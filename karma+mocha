1.单测框架（即 mocha）Mocha的作用是运行测试脚本
 测试脚本里面应该包括一个或多个describe块，每个describe块应该包括一个或多个it块。
describe块称为“测试套件”（test suite），表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称（“加法函数的测试”），第二个参数是一个实际执行的函数。
it块称为“测试用例”（test case），表示一个单独的测试，是测试的最小单位。它也是一个函数，第一个参数是测试用例的名称（“1 加 1 应该等于 2”），第二个参数是一个实际执行的函数。
断言库有很多种，mocha 并不限制使用哪一种。上面代码引入的断言库是 chai，并且指定使用它的assert断言风格。因为这更接近其它语言的风格。
所谓"断言"，就是判断源码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误
expect断言风格 var expect = require('chai').expect;
             expect(4 + 5).to.be.equal(9); 其中equal是expect的方法
             如果expect断言不成立，就会抛出一个错误。事实上，只要不抛出错误，测试用例就算通过。

可以集成到webstorm里单测可用在run-->edit config-->mocha-(写上文件目录*.test.js 或者*.spec.js)

2.Karma 不是一个测试框架，也不是一个断言库，仅仅启动一个 http server，并通过你熟知的测试框架生成运行测试的HTML。
karma init my.conf.js命令生成配置文件
    frameworks：我们这里需要 mocha 和 chai。框架必须预先通过 npm install karma-xxx --save-dev 命令安装好，支持的框架详见：https://www.npmjs.com/browse/keyword/karma-adapter
    files：可以配置通配符把源代码和测试代码加载进来。
    browsers：需要启动的浏览器
    autoWatch：观察文件是否变动，如有变动则重新运行单测
    preprocessors 预处理器配置,这里配置哪些文件需要统计测试覆盖率, 例如, 如果你的所有代码文件都在 js文件夹中, 你就需要如下配置. 注意不要包含你所依赖的库，测试文件等等
    reports 报告配置,在配置文件中包含下面的信息来激活覆盖率报告器.
    // 浏览器
    browsers: ['PhantomJS'],
    // 测试框架
    frameworks: ['mocha', 'sinon-chai', 'phantomjs-shim'],
    // 测试报告
    reporters: ['spec', 'coverage'],
    // 测试入口文件
    files: ['./index.js'],
    // 预处理器 karma-webpack
    preprocessors: {
      './index.js': ['webpack', 'sourcemap']
    },
    // Webpack配置
    webpack: webpackConfig,
    // Webpack中间件
    webpackMiddleware: {
      noInfo: true
    },
    // 测试覆盖率报告
    // https://github.com/karma-runner/karma-coverage/blob/master/docs/configuration.md
    coverageReporter: {
      dir: './coverage',
      reporters: [
        { type: 'lcov', subdir: '.' },
        { type: 'text-summary' }
      ]
    }
优点：1. cli（command-line interface，命令行界面） 运行，webstorm下配合完美 
      2. 良好支持 mocha、jasmine 等测试框架 
      3. 支持多浏览器的测试 
      4. 生态好，插件多 
      5. 集成监控解放双手，文件变化时自动启测，类似gulp的watch功能
    
3.命令行指定测试脚本时，可以使用通配符，同时指定多个文件。
shell通配符表示： $ mocha test/{,**/}*.{js,jsx}
node通配符表示： $ mocha 'test/**/*.@(js|jsx)'

Chai是一个单元测试的验证框架，它有3种不同形式的校验：expect、should和assert。expect和should的方式让写出来的测试代码更像自然语言，让业务人员也可以看懂，
而assert方式是传统单元测试断言的方式，如果以前习惯写Java的单元测试会对这种方式比较熟悉。

4。react单元测试常常与webpack工具结合

5.测试之chai.js断言库
chai.js 是一套TDD(测试驱动开发---注重输出结果)/BDD(行为驱动开发--注重测试逻辑)的断言库
语言链修饰符：to
be
been
is
that
which
and
has
have
with
at
of
same

具体api说明：
any/all
.a(type) / .an(type)： 用来断言变量类型
.include(value) / contains(value)：Object | String | Number，包含某个内容
not 跟在链式调用后面的否定断言
deep 用来深度比较2个对象,一般用在equal和property前面
.ok 断言目标是否为真(只判断值是否为真，类似==，隐式转换)
.true/.false 断言目标是否为布尔值true,false（这里与ok的区别是不进行类型转换，只能为true/false才能通过断言）
.null 断言目标为null
.undefined 断言目标为undefined
NaN 断言目标为NaN
exist 断言目标存在，既不为null，也不为undefined
empty 断言目标的长度为0。对于数组和字符串，它检查length属性，对于对象，它检查可枚举属性的数量
arguments 断言目标是一个参数对象arguments
equal(value) 断言目标严格等于(===)value。另外，如果设置了deep标记，则断言目标深度等于value
eql(value) 断言目标深度等于value，相当于deep.equal(value)的简写
above(value) 断言目标大于（超过）value,也可接在length后来断言一个最小的长度。相比直接提供长度的好处是提供了更详细的错误消息
least(value) 断言目标不小于，也可接在length后来断言一个最小的长度。相比直接提供长度的好处是提供了更详细的错误消息
below(value) 断言目标小于，也可接在length后来断言一个最小的长度。相比直接提供长度的好处是提供了更详细的错误消息
most(value) 断言目标不大于，也可接在length后来断言一个最小的长度。相比直接提供长度的好处是提供了更详细的错误消息
length 设置.have.length标记作为比较length属性值的前缀
lengthof() 断言目标的length属性为期望的值
match(RegExp) 断言目标匹配到一个正则表达式
string(string) 断言目标字符串包含另一个字符串

